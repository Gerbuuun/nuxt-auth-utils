import { getRandomValues } from 'uncrypto'
import { encodeBase64 } from '@oslojs/encoding'
import { type H3Event, getRequestURL } from 'h3'
import type { AuthenticatorData, ClientDataType, COSEEC2PublicKey, WebAuthnCredential } from '@oslojs/webauthn'
import { AttestationStatementFormat, coseAlgorithmES256, coseEllipticCurveP256, parseAttestationObject, parseClientDataJSON } from '@oslojs/webauthn'
import { createError, useRuntimeConfig } from '#imports'
import type {
  SerializedPublicKeyCredentialCreationOptions,
  SerializedPublicKeyCredentialRequestOptions,
} from '#auth-utils'

function generateChallenge() {
  return encodeBase64(getRandomValues(new Uint8Array(32)))
}

/**
 * Generate credential creation options with base64 encoded values to be sent to the client
 * @param event H3Event
 * @param uniqueName A unique name for the user (e.g. email, username)
 * @param displayName The display name for the user
 * @returns public key credential creation options
 */
export function generateRegistrationOptions(
  event: H3Event,
  uniqueName: string,
  displayName: string,
): SerializedPublicKeyCredentialCreationOptions {
  const { rpName } = useRuntimeConfig(event).passkey

  return {
    attestation: 'none',
    challenge: generateChallenge(),
    rp: {
      id: getRequestURL(event).host,
      name: rpName,
    },
    user: {
      id: generateChallenge(), // TODO: use a real id
      name: uniqueName,
      displayName,
    },
    pubKeyCredParams: [
      {
        alg: -7, // EdDSA
        type: 'public-key',
      },
    ],
    authenticatorSelection: {
      userVerification: 'required',
    },
  }
}

/**
 * Generate credential request options with base64 encoded values to be sent to the client
 * @param event H3Event
 * @returns public key credential request options
 */
export function generateLoginOptions(event: H3Event): SerializedPublicKeyCredentialRequestOptions {
  return {
    challenge: generateChallenge(),
    rpId: getRequestURL(event).host,
    timeout: 60000,
    userVerification: 'required',
  }
}

/**
 * Validates the authenticator data
 * @param event H3Event
 * @param authenticatorData authenticator data
 */
export function validateAuthenticatorData(event: H3Event, authenticatorData: AuthenticatorData) {
  const url = getRequestURL(event)

  if (!authenticatorData.verifyRelyingPartyIdHash(url.hostname))
    throw createError({ statusCode: 401, message: 'Invalid relying party ID hash' })

  if (!authenticatorData.userPresent || !authenticatorData.userVerified)
    throw createError({ statusCode: 401, message: 'User must be present and verified' })
}

type AuthenticatorDataWithCredential = AuthenticatorData & { credential: WebAuthnCredential }

/**
 * Validates the attestation object for registration
 * @param event H3Event
 * @param encodedAttestationObject attestation object
 * @returns COSE EC2 public key and validated authenticator data
 */
export function validateAttestationObject(
  event: H3Event,
  encodedAttestationObject: Uint8Array,
): { cosePublicKey: COSEEC2PublicKey, authenticatorData: AuthenticatorDataWithCredential } {
  const { attestationStatement, authenticatorData } = parseAttestationObject(encodedAttestationObject)

  // Attestation is not supported (for now?)
  if (attestationStatement.format !== AttestationStatementFormat.None)
    throw createError({ statusCode: 401, message: 'Invalid attestation statement format' })

  validateAuthenticatorData(event, authenticatorData)

  if (authenticatorData.credential === null)
    throw createError({ statusCode: 401, message: 'Missing credential' })

  if (authenticatorData.credential.publicKey.algorithm() !== coseAlgorithmES256)
    throw createError({ statusCode: 401, message: 'Unsupported algorithm' })

  // Parse the COSE key as an EC2 key
  // .rsa() for RSA, .okp() for EdDSA, etc
  const cosePublicKey = authenticatorData.credential.publicKey.ec2()
  if (cosePublicKey.curve !== coseEllipticCurveP256)
    throw createError({ statusCode: 401, message: 'Unsupported algorithm' })

  return {
    cosePublicKey,
    authenticatorData: authenticatorData as AuthenticatorDataWithCredential,
  }
}

/**
 * Validates the client data
 * @param event H3Event
 * @param clientDataType Get (0) or Create (1)
 * @param expectedChallenge The challenge generated by the server
 * @param clientDataJSON Encoded client data
 */
export function validateClientData(
  event: H3Event,
  clientDataType: ClientDataType,
  expectedChallenge: Uint8Array,
  clientDataJSON: Uint8Array,
) {
  const url = getRequestURL(event)
  const clientData = parseClientDataJSON(clientDataJSON)

  if (clientData.type !== clientDataType)
    throw createError({ statusCode: 401, message: 'Invalid client data type' })

  if (!verifyChallenge(expectedChallenge, clientData.challenge))
    throw createError({ statusCode: 401, message: 'Invalid challenge' })

  if (clientData.origin !== url.origin)
    throw createError({ statusCode: 401, message: 'Invalid origin' })

  if (clientData.crossOrigin !== null && clientData.crossOrigin)
    throw createError({ statusCode: 401, message: 'Invalid origin' })
}

/**
 * Equal time compare of the challenge and client response
 * @param challenge The challenge generated by the server
 * @param response The response from the client
 * @returns Whether the challenge and response are equal
 */
function verifyChallenge(challenge: Uint8Array, response: Uint8Array) {
  if (challenge.byteLength !== response.byteLength) return false
  for (let i = 0; i < challenge.byteLength; i++) {
    if (challenge[i] !== response[i]) return false
  }
  return true
}
